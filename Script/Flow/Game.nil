// License Information:
// Aziella's Babbling Bubbles
// Main Game Script
// 
// 
// 
// (c) Jeroen P. Broks, 
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
// Please note that some references to data like pictures or audio, do not automatically
// fall under this licenses. Mostly this is noted in the respective files.
// 
// Version: 19.05.26
// End License Information



#use 'libs/strings'
#use 'libs/linkedlist'
#use 'libs/tables'
#use 'Script/Use/Debug'
#use 'Script/Use/Aquarium_link'
#use 'Script/Use/Mascotte'
#use 'Script/Use/Music'
#use 'Script/Use/ShowMouse'
#use 'Script/Use/Users'
#use 'Script/Use/Config' 

#macro TileSize 32
#macro FieldSize 14
#macro FieldX 40
#macro FieldY 5

#macro TubeY 5
#macro TubeTimeX 5
#macro TubeFillX 22
#macro TubeW 15
#macro TubeH 200

#macro xRotCW 500
#macro xRotCCW 550
#macro yRot 50

#macro xFlipH 500
#macro xFlipV 550
#macro yFlip 150

// needed later
var Game

table musiclist
bool intutor
var ImgBubble
var ImgTube
var ImgLevelComplete
var ImgJokerHat
var ImgTile
var RotClock
var RotCountClock
var FlipHor
var FlipVer
var IGFont
int px_SZ 
IGFont = LoadImageFont("Fonts/CaviarDreams.20.jfbf")

delegate realerror
realerror = error
#pure
local error
local assert
#endpure
error = void(string fout)
	realerror(fout.."\n\n"..debug.traceback())
end
assert = var(bewering, foutmelding)
	if not bewering then error(foutmelding) end
	return bewering
end
// NIL does not yet understand '...', I need to properly work that one out!
#pure
function errorf(fmt,...) 
	error(sprintf(fmt,...))
end
#endpure
#accept errorf

table BubCol
class TBubCol
	int R
	int G
	int B
	
	void CONSTRUCTOR(aR,aG,aB)
		self.R=aR
		self.G=aG
		self.B=aB
		BubCol[#BubCol+1]=self
	end
end

class _MapData
	bool Tut
	int MaxColor
	int MaxTime
	int FillReq
	int Joker
	
	int Filled = 0
	void CONSTRUCTOR()
		CSay("MapData created")
	end
end

class Map
	bool bubble
	int bubcol
	int corx
	int cory
	int x
	int y
	bool popping
	string nonbubble
	
	static int hoverx
	static int hovery
	static var Data

	get string Dump
		string ret
		ret = self[".dump"]
		return ret
	end
	
	set string Dump
		self[".dump"]=value
	end
	
	void CONSTRUCTOR(int x, int y)
		self.x = x
		self.y = y
	end

	
	static table Level
	static table Tiles
	static int C2Real(int x, int y)
		assert(x>=1 and x<=FieldSize,sprintf("Objects.C2REAL(%d,%d): X-coordinate out of bounds! Must be a number from 1-FieldSize",x,y))
		assert(y>=1 and y<=FieldSize,sprintf("Objects.C2REAL(%d,%d): y-coordinate out of bounds! Must be a number from 1-FieldSize",x,y))
		return x + ((y-1)*FieldSize)
	end
	
	static var Obj(int x,int y,def)
		int real
		real = C2Real(x,y)
		if def!=nil then
			Map.Level[real]=def
		end
		return Map.Level[real]
	end
	
	static string DumpAll()
		string ret
		for i,d in pairs(Map.Level) 
			ret = ret .. sprintf("Map.Level[%d]['Dump'] = \"%s\"\n",i,SafeString(d.Dump))
		end
		ret = ret .. sprintf("Map.Data['.dump'] = \"%s\"\n",SafeString(Map.Data[".dump"]))
		return ret
	end
	
	static void LoadAllFromScript(string script)
		//-- I set this in a "pure" as older Lua versions use 'loadstring' and newer versions just 'load', however newer Lua versions can bring NIL into conflict as a result
		delegate l
		delegate f
		#pure
		l = loadstring or load 
		#endpure
		f = assert(l(script))
		f()
	end
	
	static void Load(int levelnumber)
		string file
		string tag
		string fullcontent
		int ly = 0
		int ty = 0
		var lines
		var data
		var level
		var tiles
		file = Trim(sprintf("Data/Levels/%03d",levelnumber))
		CSayF("Checking: \"%s\"",file)
		assert(JCR_EntryExists(file),sprintf("Level #%d does not appear to exist!",levelnumber))
		Map.Level = {}
		CSay("Creating new MapData record")
		Map.Data = _MapData.NEW()
		CSay("Creating coding shortcuts")
		level = Map.Level
		data = Map.Data // LAAAAZY!
		CSayF("Loading: \"%s\"",file)
		fullcontent = JCR_GetString(file)
		CSay("Preparing data")
		lines = Split(fullcontent,"\n")
		CSay("Parsing")
		for ln,line in ipairs(lines)
			if left(line,1)=="#"
				// Let's do nothing at all... It's just a comment, after all
			elseif left(line,1)=="[" and right(line,1)=="]"
				tag=mid(line,2,#line-2)
				tag=tag:lower()
				CSay("= "..tag)
			else
				// Time to load SHIT!
				switch tag
					case "data"
						table p
						p = split(line,"=")
						switch p[1]
							case "Tut"
								// This dirty syntax is because of a few bugs in the early versions if NIL
								data[p[1]] = p[2]["upper"](p[2])=="YES" 
							default
								data[p[1]] = tonumber(p[2])
						end
					case "tiles"
						ty=ty+1
						if ty<=14
							assert(#line>=14,"Tile line too short!")
							for tx = 1 , 14
								string ch
								int rp
								rp = Map.C2Real(tx,ty)
								ch = mid(line,tx,1)
								Map.Tiles[rp]=tonumber(ch) or 0
								//CSayF("Tile (%d,%d); ch=%s; tonum=%d; Position: %d",tx,ty,ch,tonumber(ch) or 0,rp)
							end
						end
					case "level"
						assert(#line>=14,sprintf("Level line #%d too short! At 14 characters required!",ln))
						if #line>14 then CSayF("Level line #%d is too long!\n14 characters only and it is %d characters!\nThe rest's been truncated!",ln,#line) CSay('') CSay('') end
						ly = ly + 1
						CSayF(" = Row #%d ",ly)
						if (ly>14) 
							CSayF("Level line #%d, goes over the max quota of 14 lines!",ly) 
						else
							for lx = 1 , 14
								string ch
								ch = mid(line,lx,1)
								ch = ch:upper()
								int tp
								var mp
								tp = Map.C2Real(lx,ly)
								level[tp]=level[tp] or Map.NEW(lx*TileSize,((-TileSize)*16)+TileSize*ly)
								switch ch
									case "1" "2" "3" "4" "5" "6" "7" "8" "9"
										mp=level[tp]
										mp.bubble=true
										mp.bubcol=tonumber(ch) or 0
									case "J"
										mp=level[tp]
										mp.bubble=false
										mp.nonbubble="Joker"
										mp.x = math.random(0,Screen.Width)
										mp.y = math.random(0,Screen.Height)
									case "R"
										mp=level[tp]
										mp.bubble=true
										mp.bubcol=math.random(1,Map.Data.MaxColor)
									default
										error("Unknown level tag >> "..ch)
								end
							end
						end
					default
						error(sprintf("Instructions for unknown tag '%s' cannot be dealt with",tag))
				end
			end
		end
	end
	
	static void GenerateBubble(int x, int y)
		var obj
		obj = Map.NEW(x,y)
		obj.x = FieldX + ((x-1)*32)
		if Map.Data.Joker>0 and math.random(1,Map.Data.Joker)==1
			obj.x=math.random(-8000,8000)
			obj.y=math.random(-8000,8000)
			obj.bubble=false
			obj.nonbubble="Joker"
			return
		end
		obj.bubble=true
		obj.bubcol=math.random(1,Map.Data.MaxColor)
		for iy=1,FieldSize
			var testobj
			testobj = Map.Level[Map.C2Real(x,iy)]
			if testobj and iy!=y and obj.y>=testobj.y
				obj.y=testobj.y-64
			end
		end
		Map.Level[Map.C2Real(x,y)]=obj
	end
	
	static void DrawReal(int idx)
		var obj
		obj = Map.Level[idx]
		if obj.bubble
			SetColor(BubCol[obj.bubcol]["R"],BubCol[obj.bubcol]["G"],BubCol[obj.bubcol]["B"])
			ImgBubble.Draw(obj.x,obj.y)
		end
		if obj.nonbubble!=""
			Color(255,255,255)
			switch obj.nonbubble:upper()
				case "JOKER"
					ImgJokerHat.Draw(obj.x,obj.y)
				default
					error(sprintf("I don't know non-bubble type: %s!",obj.nonbubble))
			end
		end
	end
	
	static void Draw(int x, int y, dontmove)
		int idx
		idx = Map.C2Real(x,y)
		if Map.Tiles[idx] and Map.Tiles[idx]>0
			int tr
			int tg
			int tb
			int tc
			tc = Map.Tiles[idx]
			tr = (240+(tc*10))
			tg = (100+(tc*15))
			tb =       tc*25
			SetColor(tr,tg,tb)
			ImgTile.Draw(FieldX + ((x-1)*TileSize),FieldY + ((y-1)*TileSize))
		end
		if not dontmove
			int cx
			int cy
			var obj
			cx = FieldX + ((x-1)*TileSize)
			cy = FieldY + ((y-1)*TileSize)
			obj = Map.Level[idx]
			if not obj
				if y==1 
					Map.GenerateBubble(x,y)
				else
					int idxabove
					idxabove = Map.C2Real(x,y-1)
					Map.Level[idx] = Map.Level[idxabove]
					Map.Level[idxabove] = nil // GOODBYE!!
				end
			else
				if (obj.x<cx) then obj.x = obj.x + 2 end
				if (obj.x>cx) then obj.x = obj.x - 2 end
				if (obj.y<cy) then obj.y = obj.y + 2 end
				if (obj.y>cy) then obj.y = obj.y - 2 end
				if Mouse.X>cx and Mouse.Y>cy and Mouse.X<cx+TileSize and Mouse.Y<cy+TileSize
					Map.hoverx = x
					Map.hovery = y
					Color(math.random(1,255),math.random(1,255),math.random(1,255))
					Rect(cx, cy, TileSize, TileSize, 'line')
				end
			end
		end
		if Map.Level[idx] then Map.DrawReal(idx) end
	end
	
	static void DrawAll(dontmove)
		Map.hoverx = 0
		Map.hovery = 0
		for y=1,FieldSize
			for x=1,FieldSize
				Map.Draw(x,y,dontmove)
				
			end
		end
	end
	
	static void RotateR()
		table tempfield
		for ax=1,FieldSize
			for ay=1, FieldSize
				int ridx
				int tidx
				ridx = Map.C2Real(ax,ay)
				tidx = Map.C2Real((FieldSize-ay) + 1,ax )
				tempfield[tidx]=Map.Level[ridx]
			end
		end
		Map.Level = tempfield
	end 
	
	static void RotateL()
		table tempfield
		for ax=1,FieldSize
			for ay=1, FieldSize
				int ridx
				int tidx
				ridx = Map.C2Real(ax,ay)
				tidx = Map.C2Real(ay,(FieldSize-ax) + 1 )
				tempfield[tidx]=Map.Level[ridx]
			end
		end
		Map.Level = tempfield
	end 

	static void FlipH()
		table tempfield
		for ax=1,FieldSize
			for ay=1, FieldSize
				int ridx
				int tidx
				ridx = Map.C2Real(ax,ay)
				tidx = Map.C2Real((FieldSize-ax) + 1,ay)
				tempfield[tidx]=Map.Level[ridx]
			end
		end
		Map.Level = tempfield
	end 
	
	static void FlipV()
		table tempfield
		for ax=1,FieldSize
			for ay=1, FieldSize
				int ridx
				int tidx
				ridx = Map.C2Real(ax,ay)
				tidx = Map.C2Real(ax, (FieldSize-ay) + 1 )
				tempfield[tidx]=Map.Level[ridx]
			end
		end
		Map.Level = tempfield
	end 
	
	static void Pop(int x, int y)
		var obj
		int popped
		table q
		q[1]=1
		q[2]=-1
		void minipop(int x, int y, int color)			
			var a
			a = Map.Level[Map.C2Real(x,y)]
			if not a then return end
			a.popping=true
			for i in each(q)
				if x+i>=1 and x+i<=FieldSize then a = Map.Level[Map.C2Real(x+i,y)];  if (a.bubble and (not a.popping) and a.bubcol==color) or a.nonbubble:upper()=="JOKER" then minipop(x+i,y,color) end end
				if y+i>=1 and y+i<=FieldSize then a = Map.Level[Map.C2Real(x,y+i)];  if (a.bubble and (not a.popping) and a.bubcol==color) or a.nonbubble:upper()=="JOKER" then minipop(x,y+i,color) end end
			end
			popped = popped + 1
		end
		obj=Map.Level[Map.C2Real(x,y)]
		minipop(x,y,obj.bubcol)
		if popped<3 then return end
		for i=1,FieldSize*FieldSize do
			var obj
			obj=Map.Level[i]
			if obj and obj.popping then
				Map.Level[i]=nil // Popped!
			end
		end
		Game.Score = Game.Score + math.ceil(popped*(popped/2.5))
		if Map.Data.FillReq>0
			Map.Data.Filled = Map.Data.Filled + (popped*popped)
		end
		CSayF("Player popped %5d bubbles!",popped)
	end
	
end

class TGame
	int Score = 0
	int Level = 1
	readonly table tools
	private table ttools
	private table mtools

	get int TileCount
		int ret
		for y=1,FieldSize
			for x=1,FieldSize
				ret = ret + (Map.Tiles[Map.C2Real(x,y)] or 0)
			end
		end
		return ret
	end

	
	void CONSTRUCTOR()
		table tool2number
		table number2tool
		tool2number.bomb = 1
		number2tool[1]="bomb"
		self.mtools.__index = var(t,k)
			switch type(k)
				case "string"
					if k:upper()=="EACH"
						int i
						return var()
							i=i+1
							if i>#number2tool 
								return nil,nil // nothing!
							end
							return i,number2tool[i]
						end
					end
					assert(tool2number[k],"GET:I don't know tool '"..k.."'")
					return self.ttools[tool2number[k]] or 0
				case "number"
					assert(number2tool[k],"GET:I don't know tool #"..k)
					return self.ttools[k]
				default
					error("GET:I cannot deal with tools indexed with a "..type(k))
			end
		end
		self.mtools.__newindex = int(t,k,v)
			switch type(k)
				case "string"
					assert(tool2number[k],"SET:I don't know tool '"..k.."'")
					self.ttools[tool2number[k]] = tonumber(v) or 0
				case "number"
					assert(number2tool[k],"SET:I don't know tool #"..k)
					self.ttools[k] = tonumber(v) or 0
				default
					error("SET:I cannot deal with tools indexed with a "..type(k))
			end
		end
		setmetatable(self.tools,self.mtools)
	end
end
var Tools
Game = TGame.NEW()
Tools = Game.tools // Quick references, because I am LAZY!

class TScoreShow
	static table nums
	int Old
	int Show
	string Link
	var Text
	string Caption
	var CaptionText
	get int Actual
		return Game[self.Link]
	end
	set int Actual
		Game[self.Link]=value
	end
	
	void Draw(int y)
		int verschil
		SetColor(255,180,0)
		self.CaptionText.Draw(Screen.Width-5,y,TEXT_ALIGN_RIGHT)
		SetColor(255,255,255)
		if self.Show>=self.Actual
			self.Show=self.Actual
		else
			verschil = self.Actual-self.Show
			if verschil<10
				self.Show = self.Show + 1
			end
			for i in each(self.nums)
				if verschil>i
					self.Show=self.Show+math.random(0,i-5)
				end
			end
		end
		if (not self.Text) or self.Old!=self.Show
			self.Text = IGFont.Text(""..self.Show)
		end
		self.Text.Draw(Screen.Width-5,y+35,TEXT_ALIGN_RIGHT)
	end
	
	void CONSTRUCTOR(string setCaption,string setLink)
		assert(type(Game[setLink])=="number","ScoreShow can only be used with numberic fields")
		self.Link=setLink
		self.Old=self.Actual
		self.Show=self.Actual
		self.Caption=self.Caption
		self.CaptionText = IGFont.Text(setCaption)
		if #self.nums==0
			self.nums = {10,25,50,100,250,1000}
		end
	end
end

var SScore
var SLevel
var STiles
SScore = TScoreShow.NEW("Score","Score")
SLevel = TScoreShow.NEW("Level","Level")
STiles = TScoreShow.NEW("Tiles left","TileCount")

// Random Tunes
void GetRandomTunes()
	for k,_ in spairs(JCR_EntryList(true))
		if prefixed(k,'MUSIC/PUZZLE')
			musiclist[#musiclist+1]=k
			CSayF("Added random tune: %s",k)
		end
	end
end

void RandomTune()
	int r
	string tn
	r = math.random(1,#musiclist)
	tn = musiclist[r]
	CSayF("Starting tune #%d >> %s!",r,tn)
	Music.Start(tn)
end


// Level completion checks
var CompletionCD
var LevelCompletionFunctions
LevelCompletionFunctions = TLinkedList.NEW()
do
	bool CheckFilledUp()
		return Map.Data.FillReq<=0 or Map.Data.FillReq<=Map.Data.Filled
	end
	bool AllTilesBroken()
		return Game.TileCount<=0
	end
	bool GirlHome()
		return true // The true code comes later!
	end
	
	LevelCompletionFunctions.AddLast(CheckFilledUp)
	LevelCompletionFunctions.AddLast(AllTilesBroken)
	LevelCompletionFunctions.AddLast(GirlHome)
end

bool LevelComplete()
	bool ret = true
	for chk in LevelCompletionFunctions.Each
		ret = ret and chk()
	end
	return ret
end

// Callback functions
global void BUB_Load()
	px_SZ = FieldSize * TileSize
	TBubCol.NEW(255,0,0)
	TBubCol.NEW(0,255,0)
	TBubCol.NEW(0,0,255)
	TBubCol.NEW(255,255,0)
	TBubCol.NEW(255,0,255)
	TBubCol.NEW(0,255,255)
	TBubCol.NEW(255,180,0)
	TBubCol.NEW(255,180,180)
	TBubCol.NEW(180,0,255)
	if (not SuperGlobal.Map) or SuperGlobal.Map=="" or SuperGlobal.Map=="nil"
		Map.Load(Game.Level)
	end
	ImgLevelComplete = LoadImage("GFX/General/LevelComplete.png")
	ImgBubble        = LoadImage("GFX/Levels/Bubbles/Bubble.png")
	ImgJokerHat      = LoadImage("GFX/Levels/Xtra/Joker Hat.png")
	ImgTile          = LoadImage("GFX/Levels/Tiles/Tile.png")
	ImgTube          = LoadImage("GFX/Game/Tube.png")
	RotClock         = LoadImage("GFX/Game/RotateClockwise.png")
	RotCountClock    = LoadImage("GFX/Game/RotateCounterClockwise.png")
	FlipHor          = LoadImage("GFX/Game/HFlip.png")
	FlipVer          = LoadImage("GFX/Game/VFlip.png")
	GetRandomTunes()
	RandomTune()
end

global void BUB_Draw()
	// Aquarium
	DrawAquarium()
	
	// Bubbles background
	GraphColor.Alpha=123
	SetColor(0,0,0)
	Rect(FieldX,FieldY,px_SZ,px_SZ)
	SetColor(255,255,255)
	GraphColor.Alpha=255
	
	// Score screen
	SScore.Draw(5)
	SLevel.Draw(75)
	STiles.Draw(145)
	
	// Draw level
	Map.DrawAll()
	
	// Rotation buttons
	Color(255,255,255)
	RotClock.Draw(xRotCW,yRot)
	RotCountClock.Draw(xRotCCW,yRot)
	
	// Flip buttons
	Color(255,255,255)
	FlipHor.Draw(xFlipH,yFlip)
	FlipVer.Draw(xFlipV,yFlip)
	
	// Tubes
	ImgTube.Draw(TubeTimeX,TubeY)
	if Map.Data.FillReq>0 
		if Map.Data.Filled>Map.Data.FillReq 
			Map.Data.Filled=Map.Data.FillReq
		end
		int n
		n = math.floor((Map.Data.Filled/Map.Data.FillReq)*TubeH)
		SetColor(180,0,255)
		if n>0
			Rect(TubeFillX, (TubeY + TubeH) - n,TubeW,n)
		end
		SetColor(255,255,255)
		ImgTube.Draw(TubeFillX,TubeY)
	end
	
	// Mascot
	if StateExists("MASCOT")
		DrawMascot()
	end
	
	// Complete
	if CompletionCD
		ImgLevelComplete.Draw((Screen.Width/2)-(ImgLevelComplete.Width/2),(Screen.Height/2)-(ImgLevelComplete.Height/2))
		CompletionCD = CompletionCD - 1
	end
	
	// Mouse
	ShowMouse()
end

global void BUB_Update()
	if CompletionCD
		if CompletionCD<=0
			Game.Level = Game.Level + 1
			Map.Load(Game.Level)
			if Game.Level%5==1
				RandomTune()
			end
			CompletionCD=nil // And reset for the next map!
		end
	end
end

global void BUB_KeyPressed(string name,int code)
	if name=="F1" and DebugMode
		GoConsole();
		return
	end
end

global void BUB_MousePressed(string button, int x, int y)
	if button!="Left" then return end
	if intutor
		// Comes later!
	elseif CompletionCD
		return
	else
		if     Map.hoverx!=0                           and Map.hovery!=0                               then Map.Pop(Map.hoverx,Map.hovery)
		elseif y>yRot  and y<yRot+RotClock.Height      and x>xRotCW  and x<xRotCW+RotClock.Width       then Map.RotateR()
		elseif y>yRot  and y<yRot+RotCountClock.Height and x>xRotCCW and x<xRotCCW+RotCountClock.Width then Map.RotateL() 
		elseif y>yFlip and y<yFlip+FlipHor.Height      and x>xFlipH  and x<xFlipH+FlipHor.Width        then Map.FlipH() 
		elseif y>yFlip and y<yFlip+FlipVer.Height      and x>xFlipV  and x<xFlipV+FlipVer.Width        then Map.FlipV()   end
		if LevelComplete()
			CompletionCD = 625
		end
	end
end








