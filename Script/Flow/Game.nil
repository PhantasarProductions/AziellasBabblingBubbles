// License Information:
// Aziella's Babbling Bubbles
// Main Game Script
// 
// 
// 
// (c) Jeroen P. Broks, 
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
// Please note that some references to data like pictures or audio, do not automatically
// fall under this licenses. Mostly this is noted in the respective files.
// 
// Version: 19.05.25
// End License Information


#use 'libs/strings'
#use 'libs/linkedlist'
#use 'libs/tables'
#use 'Script/Use/Debug'
#use 'Script/Use/Aquarium_link'
#use 'Script/Use/Mascotte'
#use 'Script/Use/Music'
#use 'Script/Use/ShowMouse'
#use 'Script/Use/Users'
#use 'Script/Use/Config' 

#macro TileSize 32
#macro FieldSize 14
#macro FieldX 20
#macro FieldY 5

#macro xRotCW 500
#macro xRotCCW 550
#macro yRot 50

#macro xFlipH 500
#macro xFlipV 550
#macro yFlip 150

bool intutor
var ImgBubble
var RotClock
var RotCountClock
var FlipHor
var FlipVer
var IGFont
int px_SZ 
IGFont = LoadImageFont("Fonts/CaviarDreams.20.jfbf")

table BubCol
class TBubCol
	int R
	int G
	int B
	
	void CONSTRUCTOR(aR,aG,aB)
		self.R=aR
		self.G=aG
		self.B=aB
		BubCol[#BubCol+1]=self
	end
end

class _MapData
	bool Tut
	int MaxColor
	int MaxTime
	int FillReq
	void CONSTRUCTOR()
		CSay("MapData created")
	end
end

class Map
	bool bubble
	int bubcol
	int corx
	int cory
	int x
	int y
	int tiles
	
	static var Data

	get string Dump
		string ret
		ret = self[".dump"]
		return ret
	end
	
	set string Dump
		self[".dump"]=value
	end
	
	void CONSTRUCTOR(int x, int y)
		self.x = x
		self.y = y
	end

	
	static table Level
	static int C2Real(int x, int y)
		assert(x>=1 and x<=FieldSize,sprintf("Objects.C2REAL(%d,%d): X-coordinate out of bounds! Must be a number from 1-FieldSize",x,y))
		assert(y>=1 and y<=FieldSize,sprintf("Objects.C2REAL(%d,%d): y-coordinate out of bounds! Must be a number from 1-FieldSize",x,y))
		return x + ((y-1)*FieldSize)
	end
	
	static var Obj(int x,int y,def)
		int real
		real = C2Real(x,y)
		if def!=nil then
			Map.Level[real]=def
		end
		return Map.Level[real]
	end
	
	static string DumpAll()
		string ret
		for i,d in pairs(Map.Level) 
			ret = ret .. sprintf("Map.Level[%d]['Dump'] = \"%s\"\n",i,SafeString(d.Dump))
		end
		ret = ret .. sprintf("Map.Data['.dump'] = \"%s\"\n",SafeString(Map.Data[".dump"]))
		return ret
	end
	
	static void LoadAllFromScript(string script)
		//-- I set this in a "pure" as older Lua versions use 'loadstring' and newer versions just 'load', however newer Lua versions can bring NIL into conflict as a result
		delegate l
		delegate f
		#pure
		l = loadstring or load 
		#endpure
		f = assert(l(script))
		f()
	end
	
	static void Load(int levelnumber)
		string file
		string tag
		string fullcontent
		int ly = 0
		int ty = 0
		var lines
		var data
		var level
		file = Trim(sprintf("Data/Levels/%03d",levelnumber))
		CSayF("Checking: \"%s\"",file)
		assert(JCR_EntryExists(file),sprintf("Level #%d does not appear to exist!",levelnumber))
		Map.Level = {}
		CSay("Creating new MapData record")
		Map.Data = _MapData.NEW()
		CSay("Creating coding shortcuts")
		level = Map.Level
		data = Map.Data // LAAAAZY!
		CSayF("Loading: \"%s\"",file)
		fullcontent = JCR_GetString(file)
		CSay("Preparing data")
		lines = Split(fullcontent,"\n")
		CSay("Parsing")
		for ln,line in ipairs(lines)
			if left(line,1)=="#"
				// Let's do nothing at all... It's just a comment, after all
			elseif left(line,1)=="[" and right(line,1)=="]"
				tag=mid(line,2,#line-2)
				tag=tag:lower()
				CSay("= "..tag)
			else
				// Time to load SHIT!
				switch tag
					case "data"
						table p
						p = split(line,"=")
						switch p[1]
							case "Tut"
								// This dirty syntax is because of a few bugs in the early versions if NIL
								data[p[1]] = p[2]["upper"](p[2])=="YES" 
							default
								data[p[1]] = tonumber(p[2])
						end
					case "level"
						assert(#line>=14,sprintf("Level line #%d too short! At 14 characters required!",ln))
						if #line>14 then CSayF("Level line #%d is too long!\n14 characters only and it is %d characters!\nThe rest's been truncated!",ln,#line) CSay('') CSay('') end
						ly = ly + 1
						CSayF(" = Row #%d ",ly)
						if (ly>14) 
							CSayF("Level line #%d, goes over the max quota of 14 lines!",ly) 
						else
							for lx = 1 , 14
								string ch
								ch = mid(line,lx,1)
								ch = ch:upper()
								int tp
								var mp
								tp = Map.C2Real(lx,ly)
								level[tp]=level[tp] or Map.NEW(lx*TileSize,((-TileSize)*16)+TileSize*ly)
								switch ch
									case "1" "2" "3" "4" "5" "6" "7" "8" "9"
										mp=level[tp]
										mp.bubble=true
										mp.bubcol=tonumber(ch) or 0
									case "R"
										mp=level[tp]
										mp.bubble=true
										mp.bubcol=math.random(1,Map.Data.MaxColor)
									default
										error("Unknown level tag >> "..ch)
								end
							end
						end
					default
						error(sprintf("Instructions for unknown tag '%s' cannot be dealt with",tag))
				end
			end
		end
	end
	
	static void DrawReal(int idx)
		var obj
		obj = Map.Level[idx]
		if obj.bubble
			SetColor(BubCol[obj.bubcol]["R"],BubCol[obj.bubcol]["G"],BubCol[obj.bubcol]["B"])
			ImgBubble.Draw(obj.x,obj.y)
		end
	end
	
	static void Draw(int x, int y, dontmove)
		int idx
		idx = Map.C2Real(x,y)
		if not dontmove
			int cx
			int cy
			var obj
			cx = FieldX + ((x-1)*TileSize)
			cy = FieldY + ((y-1)*TileSize)
			obj = Map.Level[idx]
			if (obj.x<cx) then obj.x = obj.x + 2 end
			if (obj.x>cx) then obj.x = obj.x - 2 end
			if (obj.y<cy) then obj.y = obj.y + 2 end
			if (obj.y>cy) then obj.y = obj.y - 2 end
		end
		Map.DrawReal(idx)
	end
	
	static void DrawAll(dontmove)
		for y=1,FieldSize
			for x=1,FieldSize
				Map.Draw(x,y,dontmove)
				
			end
		end
	end
	
	static void RotateR()
		table tempfield
		for ax=1,FieldSize
			for ay=1, FieldSize
				int ridx
				int tidx
				ridx = Map.C2Real(ax,ay)
				tidx = Map.C2Real((FieldSize-ay) + 1,ax )
				tempfield[tidx]=Map.Level[ridx]
			end
		end
		Map.Level = tempfield
	end 
	
	static void RotateL()
		table tempfield
		for ax=1,FieldSize
			for ay=1, FieldSize
				int ridx
				int tidx
				ridx = Map.C2Real(ax,ay)
				tidx = Map.C2Real(ay,(FieldSize-ax) + 1 )
				tempfield[tidx]=Map.Level[ridx]
			end
		end
		Map.Level = tempfield
	end 

	static void FlipH()
		table tempfield
		for ax=1,FieldSize
			for ay=1, FieldSize
				int ridx
				int tidx
				ridx = Map.C2Real(ax,ay)
				tidx = Map.C2Real((FieldSize-ax) + 1,ay)
				tempfield[tidx]=Map.Level[ridx]
			end
		end
		Map.Level = tempfield
	end 
	
	static void FlipV()
		table tempfield
		for ax=1,FieldSize
			for ay=1, FieldSize
				int ridx
				int tidx
				ridx = Map.C2Real(ax,ay)
				tidx = Map.C2Real(ax, (FieldSize-ay) + 1 )
				tempfield[tidx]=Map.Level[ridx]
			end
		end
		Map.Level = tempfield
	end 
	
end

class TGame
	int Score = 0
	int Level = 1
	readonly table tools
	private table ttools
	private table mtools
	
	void CONSTRUCTOR()
		table tool2number
		table number2tool
		tool2number.bomb = 1
		number2tool[1]="bomb"
		self.mtools.__index = var(t,k)
			switch type(k)
				case "string"
					if k:upper()=="EACH"
						int i
						return var()
							i=i+1
							if i>#number2tool 
								return nil,nil // nothing!
							end
							return i,number2tool[i]
						end
					end
					assert(tool2number[k],"GET:I don't know tool '"..k.."'")
					return self.ttools[tool2number[k]] or 0
				case "number"
					assert(number2tool[k],"GET:I don't know tool #"..k)
					return self.ttools[k]
				default
					error("GET:I cannot deal with tools indexed with a "..type(k))
			end
		end
		self.mtools.__newindex = int(t,k,v)
			switch type(k)
				case "string"
					assert(tool2number[k],"SET:I don't know tool '"..k.."'")
					self.ttools[tool2number[k]] = tonumber(v) or 0
				case "number"
					assert(number2tool[k],"SET:I don't know tool #"..k)
					self.ttools[k] = tonumber(v) or 0
				default
					error("SET:I cannot deal with tools indexed with a "..type(k))
			end
		end
		setmetatable(self.tools,self.mtools)
	end
end
var Game
var Tools
Game = TGame.NEW()
Tools = Game.tools // Quick references, because I am LAZY!

class TScoreShow
	static table nums
	int Old
	int Show
	string Link
	var Text
	string Caption
	var CaptionText
	get int Actual
		return Game[self.Link]
	end
	set int Actual
		Game[self.Link]=value
	end
	
	void Draw(int y)
		int verschil
		SetColor(255,180,0)
		self.CaptionText.Draw(Screen.Width-5,y,TEXT_ALIGN_RIGHT)
		SetColor(255,255,255)
		if self.Show>=self.Actual
			self.Show=self.Actual
		else
			verschil = self.Actual-self.Show
			if verschil<10
				self.Show = self.Show + 1
			end
			for i in each(self.nums)
				if verschil>i
					self.Show=self.Self+math.random(0,i-5)
				end
			end
		end
		if (not self.Text) or self.Old!=self.Show
			self.Text = IGFont.Text(""..self.Show)
		end
		self.Text.Draw(Screen.Width-5,y+35,TEXT_ALIGN_RIGHT)
	end
	
	void CONSTRUCTOR(string setCaption,string setLink)
		assert(type(Game[setLink])=="number","ScoreShow can only be used with numberic fields")
		self.Link=setLink
		self.Old=self.Actual
		self.Show=self.Actual
		self.Caption=self.Caption
		self.CaptionText = IGFont.Text(setCaption)
		if #self.nums==0
			self.nums = {10,25,50,100,250,1000}
		end
	end
end

var SScore
var SLevel
SScore = TScoreShow.NEW("Score","Score")
SLevel = TScoreShow.NEW("Level","Level")

global void BUB_Load()
	px_SZ = FieldSize * TileSize
	TBubCol.NEW(255,0,0)
	TBubCol.NEW(0,255,0)
	TBubCol.NEW(0,0,255)
	TBubCol.NEW(255,255,0)
	TBubCol.NEW(255,0,255)
	TBubCol.NEW(0,255,255)
	TBubCol.NEW(255,180,0)
	TBubCol.NEW(255,180,180)
	TBubCol.NEW(180,0,255)
	if (not SuperGlobal.Map) or SuperGlobal.Map=="" or SuperGlobal.Map=="nil"
		Map.Load(Game.Level)
	end
	ImgBubble = LoadImage("GFX/Levels/Bubbles/Bubble.png")
	RotClock      = LoadImage("GFX/Game/RotateClockwise.png")
	RotCountClock = LoadImage("GFX/Game/RotateCounterClockwise.png")
	FlipHor       = LoadImage("GFX/Game/HFlip.png")
	FlipVer       = LoadImage("GFX/Game/VFlip.png")
end

global void BUB_Draw()
	// Aquarium
	DrawAquarium()
	
	// Bubbles background
	GraphColor.Alpha=123
	SetColor(0,0,0)
	Rect(FieldX,FieldY,px_SZ,px_SZ)
	SetColor(255,255,255)
	GraphColor.Alpha=255
	
	// Score screen
	SScore.Draw(5)
	SLevel.Draw(75)
	
	// Draw level
	Map.DrawAll()
	
	// Rotation buttons
	Color(255,255,255)
	RotClock.Draw(xRotCW,yRot)
	RotCountClock.Draw(xRotCCW,yRot)
	
	// Flip buttons
	Color(255,255,255)
	FlipHor.Draw(xFlipH,yFlip)
	FlipVer.Draw(xFlipV,yFlip)
	
	// Mascot
	if StateExists("MASCOT")
		DrawMascot()
	end
	
	// Mouse
	ShowMouse()
end

global void BUB_KeyPressed(string name,int code)
	if name=="F1" and DebugMode
		GoConsole();
		return
	end
end

global void BUB_MousePressed(string button, int x, int y)
	if button!="Left" then return end
	if intutor
		// Comes later!
	else
		if     y>yRot  and y<yRot+RotClock.Height      and x>xRotCW  and x<xRotCW+RotClock.Width       then Map.RotateR()
		elseif y>yRot  and y<yRot+RotCountClock.Height and x>xRotCCW and x<xRotCCW+RotCountClock.Width then Map.RotateL() end
		if     y>yFlip and y<yFlip+FlipHor.Height      and x>xFlipH  and x<xFlipH+FlipHor.Width        then Map.FlipH() 
		elseif y>yFlip and y<yFlip+FlipVer.Height      and x>xFlipV  and x<xFlipV+FlipVer.Width        then Map.FlipV()   end
	end
end





